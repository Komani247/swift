= Swift

* http://github.com/shanna/swift

== Description

A rational rudimentary object relational mapper.

== Dependencies

* ruby   >= 1.9.1
* dbic++ >= 0.1.6
* mysql  >= 5.0.17 or postgresql >= 8.4

dbic++ can be found here http://github.com/deepfryed/dbicpp

== Features

* Multiple databases.
* Prepared statements.
* Bind values.
* Transactions and named save points.
* EventMachine asynchronous interface.
* Migrations.

== Performance

Swift prefers performance when it doesn't compromise the Ruby-ish interface. It's unfair to compare Swift to DataMapper
and ActiveRecord which suffer under the weight of support for many more databases and legacy/alternative Ruby
implementations. That said obviously if Swift were slower it would be redundant so benchmark code does exist in
http://github.com/shanna/swift/tree/master/benchmarks

== Synopsis

=== DB

  require 'swift'
  require 'etc'

  Swift.trace true # Debugging.

  Swift.setup user: Etc.getlogin, driver: 'postgresql', db: 'swift'

  # Block form db context.
  Swift.db do
    execute('drop table if exists users')
    execute('create table users(id serial, name text, email text)')

    # Save points are supported.
    transaction :named_save_point do
      st = prepare('insert into users (name, email) values (?, ?)')
      puts st.execute('Apple Arthurton', 'apple@arthurton.local').insert_id
      puts st.execute('Benny Arthurton', 'benny@arthurton.local').insert_id
    end

    # Block result iteration.
    prepare('select * from users').execute do |row|
      puts row.inspect
    end

    # Enumerable.
    result = prepare('select * from users where name like ?').execute('Benny%')
    puts result.first
  end

=== DB Resources

Rudimentary object mapping. Provides a definition to the db methods for prepared (and cached) statements plus native
primitive Ruby type conversion.

  require 'swift'
  require 'etc'

  Swift.trace true # Debugging.

  Swift.setup user: Etc.getlogin, driver: 'postgresql', db: 'swift'

  class User < Swift.resource do
      store    :users
      property :id,         Integer, serial: true, key: true
      property :name,       String
      property :email,      String
      property :updated_at, Time
    end
  end # User

  Swift.db do
    migrate! User

    # Select Resource instead of Hash.
    users = prepare(User, 'select * from users limit 1').execute

    # Make a change and update.
    users.each{|user| user.updated_at = Time.now}
    update(User, *users)

    # Get a specific user by id.
    user = get(User, id: 1)
    puts user.name, user.email
  end

=== Resources CRUD

  require 'swift'
  require 'etc'

  Swift.setup user: Etc.getlogin, driver: 'postgresql', db: swift

  # Resource
  class User < Swift.resource do
      store    :users
      property :id,    Integer, serial: true, key: true
      property :name,  String
      property :email, String
    end
  end # User

  # Migrate it.
  User.migrate!

  # Create
  User.create name: 'Apple Arthurton', email: 'apple@arthurton.local' # => User

  # Get by key.
  user = User.get id: 1

  # Alter attribute and update in one.
  user.update name: 'Jimmy Arthurton'

  # Alter attributes and update.
  user.name = 'Apple Arthurton'
  user.update

  # Destroy
  user.destroy

=== Conditions SQL syntax.

SQL is easy and most people know it so Swift ORM provides a simple symbol like syntax to convert resource
names to field names.

  class User < Swift.resource do
      store    :users
      property :id,    Integer, serial: true, key: true
      property :age,   Integer, field: 'ega'
      property :name,  String,  field: 'eman'
      property :email, String,  field: 'liame'
    end
  end # User

  # Convert :name and :age to fields.
  # select * from users where eman like '%Arthurton' and ega > 20
  users = User.all(':name like ? and :age > ?', '%Arthurton', 20)

== TODO

* Explicitly register types (less magic if you wish to create your own types).
* Adapter factory and explicit registration (same as types).
* Actually hook up the IdentityMap.
* Tests.
* Naming. Is it a model, resource, tuple, records, row etc.
* Tighter coupling of extension. Remove more wrapping, subclassing and re-opening.
* Assertions for dumb stuff. model < Model for methods in Adapter.
* Profile.

== Contributing

Go nuts! There is no style guide and I do not care if you write tests or comment code. If you write something neat just
send a pull request, tweet, email or yell it at me line by line in person.

